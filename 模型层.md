给模型添加__str__()方法，让模型能够在shell中展示结果

查找数据的时候，django用的不是select *, 而是把所有字段列出来


详细分析 Publisher.objects.all() 这行代码:
• 首先，Publisher 是我们定义的模型。这没什么可意外的，想查找数据就应该使用相应的模型。
• 然后，访问 objects 属性。这叫**管理器(manager)**，在第 9 章详述。现在，你只需知道，管理器负责 所有“表层”数据操作，包括(最重要的)数据查询。所有模型都自动获得一个 objects 管理器，需要 查询模型实例时都要使用它。
• 最后，调用 all() 方法。这是 objects 管理器的一个方法，返回数据库中的所有行。虽然返回的对象 看似一个列表，但其实是一个查询集合(QuerySet)——表示数据库中一系列行的对象。附录 C 将详 细说明查询集合。本章都将把它视作它所模仿的列表。

#### 过滤数据
可以传多个参数给filter方法
Publisher.objects.filter(name='Apress',state_province='CA') 
<==> select * from books_publisher where name = 'Apress' and state_province='CA'

查找操作默认使用sql的 = 操作符精准查找
#### 模糊查找
**以下返回均为QuerySet对象**
Publisher.objects.filter(name__contains="press")
<==> select * from books_publisher where name like '%press%'
还支持其他查找类型：有icontains(不区分大小写的like)， startswith和endswith,以及range(sql的between语句)

#### 检索单个对象
**只返回一个对象,查询不到的时候会抛出Publisher.DoesNotExist异常**
Publisher.objects.get(name='aaa')


#### 排序数据
如果需要反向排序，方法是在字段名称前面加上“-”（减号）
如果想根据多个字段排序(以第一个字段排不出顺序时使用第二个字段)，提供多个参数:
order_by("name","address")

虽然 order_by() 有一定的灵活性，但是每次都调用它相当繁琐。多数时候，我们始终使用同一个字段排序。
此时，可以在模型中指定默认排序:
class Publisher(models.Model):
name = models.CharField(max_length=30)
address = models.CharField(max_length=50)
city = models.CharField(max_length=60) state_province = models.CharField(max_length=30) country = models.CharField(max_length=50) website = models.URLField()
def __str__(self): return self.name
        class Meta:
            ordering = ['name']
            
# 改，单个多个都可以
Publisher.objects.filter(id='11').update(name='aaaa')

update() 方法可以在任何 QuerySet 对象上调用，这意味着可以通过它批量编辑多个记录。
下述代码把每个 Publisher 记录的 country 列都由 'U.S.A.' 改为 'USA':
Publisher.objects.all().update(country='USA')
# 删
删除一个对象，只需在对象上调用 delete() 方法:
删除多个Publisher.objects.filter(country='USA').delete()
为了防止不小心把表中的数据都删除，想删除表中的一切数据时，Django 要求必须显式调 用 all() 方法。例如，下述代码无效:
如果只想删除部分数据，无需调用 all() 方法。下面再以前面的一个示例为例: >>> Publisher.objects.filter(country='USA').delete()
